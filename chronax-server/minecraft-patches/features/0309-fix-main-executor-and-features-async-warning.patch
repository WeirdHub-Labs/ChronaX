diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/task/ChunkUpgradeGenericStatusTask.java b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/task/ChunkUpgradeGenericStatusTask.java
index 25d8da4..e90f84d 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/task/ChunkUpgradeGenericStatusTask.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/task/ChunkUpgradeGenericStatusTask.java
@@ -132,7 +132,8 @@ public final class ChunkUpgradeGenericStatusTask extends ChunkProgressionTask im
             return;
         }
 
-        if (!completeFuture.isDone() && !((ChunkSystemChunkStatus)this.toStatus).moonrise$getWarnedAboutNoImmediateComplete().getAndSet(true)) {
+        final boolean expectedAsyncCompletion = generation && this.toStatus == ChunkStatus.FEATURES;
+        if (!expectedAsyncCompletion && !completeFuture.isDone() && !((ChunkSystemChunkStatus)this.toStatus).moonrise$getWarnedAboutNoImmediateComplete().getAndSet(true)) {
             LOGGER.warn("Future status not complete after scheduling: " + this.toStatus.toString() + ", generate: " + generation);
         }
 
diff --git a/net/minecraft/server/level/ChunkMap.java b/net/minecraft/server/level/ChunkMap.java
index e102536..8508622 100644
--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -234,7 +234,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             level
         );
         this.setServerViewDistance(serverViewDistance);
-        this.worldGenContext = new WorldGenContext(level, generator, structureManager, this.lightEngine, null, this::setChunkUnsaved); // Paper - rewrite chunk system
+        this.worldGenContext = new WorldGenContext(level, generator, structureManager, this.lightEngine, mainThreadExecutor, this::setChunkUnsaved); // Paper - rewrite chunk system
     }
 
     private void setChunkUnsaved(ChunkPos chunkPos) {
diff --git a/net/minecraft/world/level/chunk/status/ChunkStatusTasks.java b/net/minecraft/world/level/chunk/status/ChunkStatusTasks.java
index c937fc1..77a21cf 100644
--- a/net/minecraft/world/level/chunk/status/ChunkStatusTasks.java
+++ b/net/minecraft/world/level/chunk/status/ChunkStatusTasks.java
@@ -26,6 +26,14 @@ import org.slf4j.Logger;
 public class ChunkStatusTasks {
     private static final Logger LOGGER = LogUtils.getLogger();
 
+    private static java.util.concurrent.Executor mainThreadExecutor(final WorldGenContext worldGenContext) {
+        final java.util.concurrent.Executor executor = worldGenContext.mainThreadExecutor();
+        if (executor != null) {
+            return executor;
+        }
+        return worldGenContext.level().getChunkSource().mainThreadProcessor;
+    }
+
     private static boolean isLighted(ChunkAccess chunk) {
         return chunk.getPersistedStatus().isOrAfter(ChunkStatus.LIGHT) && chunk.isLightCorrect();
     }
@@ -146,10 +154,18 @@ public class ChunkStatusTasks {
             chunk,
             EnumSet.of(Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE)
         );
-        WorldGenRegion worldGenRegion = new WorldGenRegion(serverLevel, cache, step, chunk);
-        worldGenContext.generator().applyBiomeDecoration(worldGenRegion, chunk, serverLevel.structureManager().forWorldGenRegion(worldGenRegion));
+        final WorldGenRegion worldGenRegion = new WorldGenRegion(serverLevel, cache, step, chunk);
+        final var generator = worldGenContext.generator();
+
+        // Keep vanilla decoration off-thread, but run plugin populators on main for Bukkit compatibility.
+        generator.addVanillaDecorations(worldGenRegion, chunk, serverLevel.structureManager().forWorldGenRegion(worldGenRegion));
         Blender.generateBorderTicks(worldGenRegion, chunk);
-        return CompletableFuture.completedFuture(chunk);
+
+        return CompletableFuture.supplyAsync(() -> {
+            final WorldGenRegion mainThreadRegion = new WorldGenRegion(serverLevel, cache, step, chunk);
+            generator.applyBiomeDecoration(mainThreadRegion, chunk, serverLevel.structureManager().forWorldGenRegion(mainThreadRegion), false);
+            return chunk;
+        }, mainThreadExecutor(worldGenContext));
     }
 
     static CompletableFuture<ChunkAccess> initializeLight(
@@ -202,7 +218,7 @@ public class ChunkStatusTasks {
             wrapped.registerTickContainerInLevel(serverLevel);
             wrapped.setUnsavedListener(worldGenContext.unsavedListener());
             return wrapped;
-        }, worldGenContext.mainThreadExecutor());
+        }, mainThreadExecutor(worldGenContext));
     }
 
     public static void postLoadProtoChunk(ServerLevel level, ValueInput.ValueInputList input, ChunkPos pos) { // Paper - rewrite chunk system - add ChunkPos param
