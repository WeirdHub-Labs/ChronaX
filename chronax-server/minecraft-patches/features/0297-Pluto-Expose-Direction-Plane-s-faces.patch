From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Yive <6853318+Yive@users.noreply.github.com>
Date: Tue, 6 May 2025 22:14:55 -0700
Subject: [PATCH] Pluto: Expose Direction$Plane's faces

The JMH benchmark of this patch can be found in SunBox's `CachedEnumValuesForLoop`

Original license: GPL-3.0
Original project: https://github.com/Yive/Pluto

diff --git a/net/minecraft/core/Direction.java b/net/minecraft/core/Direction.java
index 8447557..22428e3 100644
--- a/net/minecraft/core/Direction.java
+++ b/net/minecraft/core/Direction.java
@@ -627,7 +627,7 @@ public enum Direction implements StringRepresentable, ca.spottedleaf.moonrise.pa
         HORIZONTAL(new Direction[]{Direction.NORTH, Direction.EAST, Direction.SOUTH, Direction.WEST}, new Direction.Axis[]{Direction.Axis.X, Direction.Axis.Z}),
         VERTICAL(new Direction[]{Direction.UP, Direction.DOWN}, new Direction.Axis[]{Direction.Axis.Y});
 
-        private final Direction[] faces;
+        public final Direction[] faces; // Pluto - Expose Direction$Plane's faces
         private final Direction.Axis[] axis;
 
         private Plane(final Direction[] faces, final Direction.Axis[] axis) {
diff --git a/net/minecraft/data/worldgen/features/VegetationFeatures.java b/net/minecraft/data/worldgen/features/VegetationFeatures.java
index 4509345..c228135 100644
--- a/net/minecraft/data/worldgen/features/VegetationFeatures.java
+++ b/net/minecraft/data/worldgen/features/VegetationFeatures.java
@@ -812,7 +812,7 @@ public class VegetationFeatures {
         WeightedList.Builder<BlockState> builder = WeightedList.builder();
 
         for (int i = minAmount; i <= maxAmount; i++) {
-            for (Direction direction : Direction.Plane.HORIZONTAL) {
+            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 builder.add(block.defaultBlockState().setValue(amountProperty, i).setValue(directionProperty, direction), 1);
             }
         }
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index e4f3d03..f0aec0e 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -1177,7 +1177,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                         // We only need to check blocks that are taller than the minimum step height
                         if (org.purpurmc.purpur.PurpurConfig.smoothSnowAccumulationStep > 0 && layersValue >= org.purpurmc.purpur.PurpurConfig.smoothSnowAccumulationStep) {
                             int layersValueMin = layersValue - org.purpurmc.purpur.PurpurConfig.smoothSnowAccumulationStep;
-                            for (Direction direction : Direction.Plane.HORIZONTAL) {
+                            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                                 BlockPos blockPosNeighbor = heightmapPos.relative(direction);
                                 BlockState blockStateNeighbor = this.getBlockState(blockPosNeighbor);
                                 if (blockStateNeighbor.is(Blocks.SNOW)) {
diff --git a/net/minecraft/world/entity/ai/behavior/PrepareRamNearestTarget.java b/net/minecraft/world/entity/ai/behavior/PrepareRamNearestTarget.java
index dfd39ff..e1039aa 100644
--- a/net/minecraft/world/entity/ai/behavior/PrepareRamNearestTarget.java
+++ b/net/minecraft/world/entity/ai/behavior/PrepareRamNearestTarget.java
@@ -145,7 +145,7 @@ public class PrepareRamNearestTarget<E extends PathfinderMob> extends Behavior<E
             List<BlockPos> list = Lists.newArrayList();
             BlockPos.MutableBlockPos mutableBlockPos = blockPos.mutable();
 
-            for (Direction direction : Direction.Plane.HORIZONTAL) {
+            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 mutableBlockPos.set(blockPos);
 
                 for (int i = 0; i < this.maxRamDistance; i++) {
diff --git a/net/minecraft/world/entity/ai/behavior/TryFindLandNearWater.java b/net/minecraft/world/entity/ai/behavior/TryFindLandNearWater.java
index d11840e..c6eddfc 100644
--- a/net/minecraft/world/entity/ai/behavior/TryFindLandNearWater.java
+++ b/net/minecraft/world/entity/ai/behavior/TryFindLandNearWater.java
@@ -40,7 +40,7 @@ public class TryFindLandNearWater {
                                     && !level.getBlockState(mutableBlockPos.setWithOffset(blockPos1, Direction.DOWN))
                                         .getCollisionShape(level, blockPos1, collisionContext)
                                         .isEmpty()) {
-                                    for (Direction direction : Direction.Plane.HORIZONTAL) {
+                                    for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                                         mutableBlockPos.setWithOffset(blockPos1, direction);
                                         if (level.getBlockState(mutableBlockPos).isAir()
                                             && level.getBlockState(mutableBlockPos.move(Direction.DOWN)).is(Blocks.WATER)) {
diff --git a/net/minecraft/world/entity/ai/behavior/TryLaySpawnOnWaterNearLand.java b/net/minecraft/world/entity/ai/behavior/TryLaySpawnOnWaterNearLand.java
index 011d820..d149b11 100644
--- a/net/minecraft/world/entity/ai/behavior/TryLaySpawnOnWaterNearLand.java
+++ b/net/minecraft/world/entity/ai/behavior/TryLaySpawnOnWaterNearLand.java
@@ -26,7 +26,7 @@ public class TryLaySpawnOnWaterNearLand {
                         if (!entity.isInWater() && entity.onGround()) {
                             BlockPos blockPos = entity.blockPosition().below();
 
-                            for (Direction direction : Direction.Plane.HORIZONTAL) {
+                            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                                 BlockPos blockPos1 = blockPos.relative(direction);
                                 if (level.getBlockState(blockPos1).getCollisionShape(level, blockPos1).getFaceShape(Direction.UP).isEmpty()
                                     && level.getFluidState(blockPos1).is(Fluids.WATER)) {
diff --git a/net/minecraft/world/entity/projectile/AbstractThrownPotion.java b/net/minecraft/world/entity/projectile/AbstractThrownPotion.java
index d26867d..44e7b63 100644
--- a/net/minecraft/world/entity/projectile/AbstractThrownPotion.java
+++ b/net/minecraft/world/entity/projectile/AbstractThrownPotion.java
@@ -57,7 +57,7 @@ public abstract class AbstractThrownPotion extends ThrowableItemProjectile {
                 this.dowseFire(blockPos1);
                 this.dowseFire(blockPos1.relative(direction.getOpposite()));
 
-                for (Direction direction1 : Direction.Plane.HORIZONTAL) {
+                for (Direction direction1 : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                     this.dowseFire(blockPos1.relative(direction1));
                 }
             }
diff --git a/net/minecraft/world/level/Level.java b/net/minecraft/world/level/Level.java
index e4d83ed..b2cb848 100644
--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -2063,7 +2063,7 @@ public abstract class Level implements LevelAccessor, UUIDLookup<Entity>, AutoCl
     public abstract Scoreboard getScoreboard();
 
     public void updateNeighbourForOutputSignal(BlockPos pos, Block block) {
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             BlockPos blockPos = pos.relative(direction);
             if (this.hasChunkAt(blockPos)) {
                 BlockState blockState = this.getBlockState(blockPos);
diff --git a/net/minecraft/world/level/block/CactusBlock.java b/net/minecraft/world/level/block/CactusBlock.java
index 292260b..d6f963f 100644
--- a/net/minecraft/world/level/block/CactusBlock.java
+++ b/net/minecraft/world/level/block/CactusBlock.java
@@ -141,7 +141,7 @@ public class CactusBlock extends Block implements BonemealableBlock { // Purpur
     }
     protected boolean canSurvive(LevelReader level, BlockPos pos) {
         // Pluto end - Check if the cactus can even survive being placed
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             BlockState blockState = level.getBlockState(pos.relative(direction));
             if ((level.getWorldBorder().world.purpurConfig.cactusBreaksFromSolidNeighbors && blockState.isSolid()) || level.getFluidState(pos.relative(direction)).is(FluidTags.LAVA)) { // Purpur - Cactus breaks from solid neighbors config
                 return false;
diff --git a/net/minecraft/world/level/block/ChorusFlowerBlock.java b/net/minecraft/world/level/block/ChorusFlowerBlock.java
index 32ba79c..faf9e7c 100644
--- a/net/minecraft/world/level/block/ChorusFlowerBlock.java
+++ b/net/minecraft/world/level/block/ChorusFlowerBlock.java
@@ -152,7 +152,7 @@ public class ChorusFlowerBlock extends Block {
     }
 
     private static boolean allNeighborsEmpty(LevelReader level, BlockPos pos, @Nullable Direction excludingSide) {
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             if (direction != excludingSide && !level.isEmptyBlock(pos.relative(direction))) {
                 return false;
             }
@@ -188,7 +188,7 @@ public class ChorusFlowerBlock extends Block {
             } else {
                 boolean flag = false;
 
-                for (Direction direction : Direction.Plane.HORIZONTAL) {
+                for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                     BlockState blockState1 = level.getBlockState(pos.relative(direction));
                     if (blockState1.is(this.plant)) {
                         if (flag) {
diff --git a/net/minecraft/world/level/block/ChorusPlantBlock.java b/net/minecraft/world/level/block/ChorusPlantBlock.java
index 47f3b00..47df6c8 100644
--- a/net/minecraft/world/level/block/ChorusPlantBlock.java
+++ b/net/minecraft/world/level/block/ChorusPlantBlock.java
@@ -95,7 +95,7 @@ public class ChorusPlantBlock extends PipeBlock {
         BlockState blockState = level.getBlockState(pos.below());
         boolean flag = !level.getBlockState(pos.above()).isAir() && !blockState.isAir();
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             BlockPos blockPos = pos.relative(direction);
             BlockState blockState1 = level.getBlockState(blockPos);
             if (blockState1.is(this)) {
diff --git a/net/minecraft/world/level/block/MossyCarpetBlock.java b/net/minecraft/world/level/block/MossyCarpetBlock.java
index 8e0e66e..73af154 100644
--- a/net/minecraft/world/level/block/MossyCarpetBlock.java
+++ b/net/minecraft/world/level/block/MossyCarpetBlock.java
@@ -134,7 +134,7 @@ public class MossyCarpetBlock extends Block implements BonemealableBlock {
         BlockState blockState1 = null;
         tip |= state.getValue(BASE);
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             EnumProperty<WallSide> propertyForFace = getPropertyForFace(direction);
             WallSide wallSide = canSupportAtFace(level, pos, direction) ? (tip ? WallSide.LOW : state.getValue(propertyForFace)) : WallSide.NONE;
             if (wallSide == WallSide.LOW) {
@@ -200,7 +200,7 @@ public class MossyCarpetBlock extends Block implements BonemealableBlock {
             BlockState blockState1 = Blocks.PALE_MOSS_CARPET.defaultBlockState().setValue(BASE, false);
             BlockState updatedState = getUpdatedState(blockState1, level, pos.above(), true);
 
-            for (Direction direction : Direction.Plane.HORIZONTAL) {
+            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 EnumProperty<WallSide> propertyForFace = getPropertyForFace(direction);
                 if (updatedState.getValue(propertyForFace) != WallSide.NONE && !placeSide.getAsBoolean()) {
                     updatedState = updatedState.setValue(propertyForFace, WallSide.NONE);
diff --git a/net/minecraft/world/level/block/RailState.java b/net/minecraft/world/level/block/RailState.java
index 3b69f95..b2c6af1 100644
--- a/net/minecraft/world/level/block/RailState.java
+++ b/net/minecraft/world/level/block/RailState.java
@@ -133,7 +133,7 @@ public class RailState {
     protected int countPotentialConnections() {
         int i = 0;
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             if (this.hasRail(this.pos.relative(direction))) {
                 i++;
             }
diff --git a/net/minecraft/world/level/block/RedStoneWireBlock.java b/net/minecraft/world/level/block/RedStoneWireBlock.java
index 9adb432..ff5ee04 100644
--- a/net/minecraft/world/level/block/RedStoneWireBlock.java
+++ b/net/minecraft/world/level/block/RedStoneWireBlock.java
@@ -158,7 +158,7 @@ public class RedStoneWireBlock extends Block {
     private BlockState getMissingConnections(BlockGetter level, BlockState state, BlockPos pos) {
         boolean flag = !level.getBlockState(pos.above()).isRedstoneConductor(level, pos);
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             if (!state.getValue(PROPERTY_BY_DIRECTION.get(direction)).isConnected()) {
                 RedstoneSide connectingSide = this.getConnectingSide(level, pos, direction, flag);
                 state = state.setValue(PROPERTY_BY_DIRECTION.get(direction), connectingSide);
@@ -211,7 +211,7 @@ public class RedStoneWireBlock extends Block {
     protected void updateIndirectNeighbourShapes(BlockState state, LevelAccessor level, BlockPos pos, int flags, int recursionLeft) {
         BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             RedstoneSide redstoneSide = state.getValue(PROPERTY_BY_DIRECTION.get(direction));
             if (redstoneSide != RedstoneSide.NONE && !level.getBlockState(mutableBlockPos.setWithOffset(pos, direction)).is(this)) {
                 mutableBlockPos.move(Direction.DOWN);
@@ -377,7 +377,7 @@ public class RedStoneWireBlock extends Block {
             }
             // Paper end - optimize redstone
 
-            for (Direction direction : Direction.Plane.VERTICAL) {
+            for (Direction direction : Direction.Plane.VERTICAL.faces) { // Pluto - Expose Direction$Plane's faces
                 level.updateNeighborsAt(pos.relative(direction), this);
             }
 
@@ -404,11 +404,11 @@ public class RedStoneWireBlock extends Block {
     }
 
     private void updateNeighborsOfNeighboringWires(Level level, BlockPos pos) {
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             this.checkCornerChangeAt(level, pos.relative(direction));
         }
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             BlockPos blockPos = pos.relative(direction);
             if (level.getBlockState(blockPos).isRedstoneConductor(level, blockPos)) {
                 this.checkCornerChangeAt(level, blockPos.above());
@@ -512,7 +512,7 @@ public class RedStoneWireBlock extends Block {
     public void animateTick(BlockState state, Level level, BlockPos pos, RandomSource random) {
         int powerValue = state.getValue(POWER);
         if (powerValue != 0) {
-            for (Direction direction : Direction.Plane.HORIZONTAL) {
+            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 RedstoneSide redstoneSide = state.getValue(PROPERTY_BY_DIRECTION.get(direction));
                 switch (redstoneSide) {
                     case UP:
@@ -591,7 +591,7 @@ public class RedStoneWireBlock extends Block {
     private void updatesOnShapeChange(Level level, BlockPos pos, BlockState oldState, BlockState newState) {
         Orientation orientation = ExperimentalRedstoneUtils.initialOrientation(level, null, Direction.UP);
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             BlockPos blockPos = pos.relative(direction);
             if (oldState.getValue(PROPERTY_BY_DIRECTION.get(direction)).isConnected() != newState.getValue(PROPERTY_BY_DIRECTION.get(direction)).isConnected()
                 && level.getBlockState(blockPos).isRedstoneConductor(level, blockPos)) {
diff --git a/net/minecraft/world/level/block/ScaffoldingBlock.java b/net/minecraft/world/level/block/ScaffoldingBlock.java
index 1fa344f..d8af8ea 100644
--- a/net/minecraft/world/level/block/ScaffoldingBlock.java
+++ b/net/minecraft/world/level/block/ScaffoldingBlock.java
@@ -165,7 +165,7 @@ public class ScaffoldingBlock extends Block implements SimpleWaterloggedBlock {
             return 0;
         }
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             BlockState blockState1 = level.getBlockState(mutableBlockPos.setWithOffset(pos, direction));
             if (blockState1.is(Blocks.SCAFFOLDING)) {
                 i = Math.min(i, blockState1.getValue(DISTANCE) + 1);
diff --git a/net/minecraft/world/level/block/SugarCaneBlock.java b/net/minecraft/world/level/block/SugarCaneBlock.java
index baa56c6..7d5e1e7 100644
--- a/net/minecraft/world/level/block/SugarCaneBlock.java
+++ b/net/minecraft/world/level/block/SugarCaneBlock.java
@@ -95,7 +95,7 @@ public class SugarCaneBlock extends Block implements BonemealableBlock { // Purp
             if (blockState.is(BlockTags.DIRT) || blockState.is(BlockTags.SAND)) {
                 BlockPos blockPos = pos.below();
 
-                for (Direction direction : Direction.Plane.HORIZONTAL) {
+                for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                     BlockState blockState1 = level.getBlockState(blockPos.relative(direction));
                     FluidState fluidState = level.getFluidState(blockPos.relative(direction));
                     if (fluidState.is(FluidTags.WATER) || blockState1.is(Blocks.FROSTED_ICE)) {
diff --git a/net/minecraft/world/level/block/VineBlock.java b/net/minecraft/world/level/block/VineBlock.java
index 5aed667..f9d65aa 100644
--- a/net/minecraft/world/level/block/VineBlock.java
+++ b/net/minecraft/world/level/block/VineBlock.java
@@ -125,7 +125,7 @@ public class VineBlock extends Block {
 
         BlockState blockState = null;
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             BooleanProperty propertyForFace = getPropertyForFace(direction);
             if (state.getValue(propertyForFace)) {
                 boolean canSupportAtFace = this.canSupportAtFace(level, pos, direction);
@@ -215,7 +215,7 @@ public class VineBlock extends Block {
 
                             BlockState blockState1 = state;
 
-                            for (Direction clockWise : Direction.Plane.HORIZONTAL) {
+                            for (Direction clockWise : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                                 if (random.nextBoolean() || !isAcceptableNeighbour(level, blockPos.relative(clockWise), clockWise)) {
                                     blockState1 = blockState1.setValue(getPropertyForFace(clockWise), false);
                                 }
@@ -246,7 +246,7 @@ public class VineBlock extends Block {
     }
 
     private BlockState copyRandomFaces(BlockState sourceState, BlockState spreadState, RandomSource random) {
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             if (random.nextBoolean()) {
                 BooleanProperty propertyForFace = getPropertyForFace(direction);
                 if (sourceState.getValue(propertyForFace)) {
diff --git a/net/minecraft/world/level/block/sounds/AmbientDesertBlockSoundsPlayer.java b/net/minecraft/world/level/block/sounds/AmbientDesertBlockSoundsPlayer.java
index ebb3a5d..0f43e03 100644
--- a/net/minecraft/world/level/block/sounds/AmbientDesertBlockSoundsPlayer.java
+++ b/net/minecraft/world/level/block/sounds/AmbientDesertBlockSoundsPlayer.java
@@ -58,7 +58,7 @@ public class AmbientDesertBlockSoundsPlayer {
         int i1 = 0;
         BlockPos.MutableBlockPos mutableBlockPos = pos.mutable();
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             mutableBlockPos.set(pos).move(direction, 8);
             if (columnContainsTriggeringBlock(level, mutableBlockPos) && i++ >= 3) {
                 return true;
diff --git a/net/minecraft/world/level/dimension/end/EndDragonFight.java b/net/minecraft/world/level/dimension/end/EndDragonFight.java
index 62ffb8e..d4991a3 100644
--- a/net/minecraft/world/level/dimension/end/EndDragonFight.java
+++ b/net/minecraft/world/level/dimension/end/EndDragonFight.java
@@ -556,7 +556,7 @@ public class EndDragonFight {
             List<EndCrystal> list = Lists.newArrayList();
             BlockPos blockPos1 = blockPos.above(1);
 
-            for (Direction direction : Direction.Plane.HORIZONTAL) {
+            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 List<EndCrystal> entitiesOfClass = this.level.getEntitiesOfClass(EndCrystal.class, new AABB(blockPos1.relative(direction, 2)));
                 if (entitiesOfClass.isEmpty()) {
                     return false; // CraftBukkit - return value
diff --git a/net/minecraft/world/level/levelgen/blending/Blender.java b/net/minecraft/world/level/levelgen/blending/Blender.java
index 001b3ce..05cd959 100644
--- a/net/minecraft/world/level/levelgen/blending/Blender.java
+++ b/net/minecraft/world/level/levelgen/blending/Blender.java
@@ -270,7 +270,7 @@ public class Blender {
                 }
             }
 
-            for (Direction direction : Direction.Plane.HORIZONTAL) {
+            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 if (region.getChunk(pos.x + direction.getStepX(), pos.z + direction.getStepZ()).isOldNoiseGeneration() != isOldNoiseGeneration) {
                     int i2 = direction == Direction.EAST ? 15 : 0;
                     int i3 = direction == Direction.WEST ? 0 : 15;
diff --git a/net/minecraft/world/level/levelgen/feature/BonusChestFeature.java b/net/minecraft/world/level/levelgen/feature/BonusChestFeature.java
index 0b97b57..e0ca4c2 100644
--- a/net/minecraft/world/level/levelgen/feature/BonusChestFeature.java
+++ b/net/minecraft/world/level/levelgen/feature/BonusChestFeature.java
@@ -40,7 +40,7 @@ public class BonusChestFeature extends Feature<NoneFeatureConfiguration> {
                     RandomizableContainer.setBlockEntityLootTable(worldGenLevel, randomSource, heightmapPos, BuiltInLootTables.SPAWN_BONUS_CHEST);
                     BlockState blockState = Blocks.TORCH.defaultBlockState();
 
-                    for (Direction direction : Direction.Plane.HORIZONTAL) {
+                    for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                         BlockPos blockPos = heightmapPos.relative(direction);
                         if (blockState.canSurvive(worldGenLevel, blockPos)) {
                             worldGenLevel.setBlock(blockPos, blockState, 2);
diff --git a/net/minecraft/world/level/levelgen/feature/CoralFeature.java b/net/minecraft/world/level/levelgen/feature/CoralFeature.java
index 2569754..22463f6 100644
--- a/net/minecraft/world/level/levelgen/feature/CoralFeature.java
+++ b/net/minecraft/world/level/levelgen/feature/CoralFeature.java
@@ -47,7 +47,7 @@ public abstract class CoralFeature extends Feature<NoneFeatureConfiguration> {
                 level.setBlock(blockPos, Blocks.SEA_PICKLE.defaultBlockState().setValue(SeaPickleBlock.PICKLES, random.nextInt(4) + 1), 2);
             }
 
-            for (Direction direction : Direction.Plane.HORIZONTAL) {
+            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 if (random.nextFloat() < 0.2F) {
                     BlockPos blockPos1 = pos.relative(direction);
                     if (level.getBlockState(blockPos1).is(Blocks.WATER)) {
diff --git a/net/minecraft/world/level/levelgen/feature/DesertWellFeature.java b/net/minecraft/world/level/levelgen/feature/DesertWellFeature.java
index e88df07..c1e2713 100644
--- a/net/minecraft/world/level/levelgen/feature/DesertWellFeature.java
+++ b/net/minecraft/world/level/levelgen/feature/DesertWellFeature.java
@@ -56,14 +56,14 @@ public class DesertWellFeature extends Feature<NoneFeatureConfiguration> {
 
             worldGenLevel.setBlock(blockPos, this.water, 2);
 
-            for (Direction direction : Direction.Plane.HORIZONTAL) {
+            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 worldGenLevel.setBlock(blockPos.relative(direction), this.water, 2);
             }
 
             BlockPos blockPos1 = blockPos.below();
             worldGenLevel.setBlock(blockPos1, this.sand, 2);
 
-            for (Direction direction1 : Direction.Plane.HORIZONTAL) {
+            for (Direction direction1 : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 worldGenLevel.setBlock(blockPos1.relative(direction1), this.sand, 2);
             }
 
diff --git a/net/minecraft/world/level/levelgen/feature/DripstoneClusterFeature.java b/net/minecraft/world/level/levelgen/feature/DripstoneClusterFeature.java
index e41abe1..d028810 100644
--- a/net/minecraft/world/level/levelgen/feature/DripstoneClusterFeature.java
+++ b/net/minecraft/world/level/levelgen/feature/DripstoneClusterFeature.java
@@ -163,7 +163,7 @@ public class DripstoneClusterFeature extends Feature<DripstoneClusterConfigurati
             if (level.getBlockState(pos.above()).getFluidState().is(FluidTags.WATER)) {
                 return false;
             } else {
-                for (Direction direction : Direction.Plane.HORIZONTAL) {
+                for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                     if (!this.canBeAdjacentToWater(level, pos.relative(direction))) {
                         return false;
                     }
diff --git a/net/minecraft/world/level/levelgen/feature/EndPodiumFeature.java b/net/minecraft/world/level/levelgen/feature/EndPodiumFeature.java
index f80c3c0..4372f9a 100644
--- a/net/minecraft/world/level/levelgen/feature/EndPodiumFeature.java
+++ b/net/minecraft/world/level/levelgen/feature/EndPodiumFeature.java
@@ -68,7 +68,7 @@ public class EndPodiumFeature extends Feature<NoneFeatureConfiguration> {
 
         BlockPos blockPos2 = blockPos.above(2);
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             this.setBlock(worldGenLevel, blockPos2.relative(direction), Blocks.WALL_TORCH.defaultBlockState().setValue(WallTorchBlock.FACING, direction));
         }
 
diff --git a/net/minecraft/world/level/levelgen/feature/MonsterRoomFeature.java b/net/minecraft/world/level/levelgen/feature/MonsterRoomFeature.java
index 586097d..36f71c1 100644
--- a/net/minecraft/world/level/levelgen/feature/MonsterRoomFeature.java
+++ b/net/minecraft/world/level/levelgen/feature/MonsterRoomFeature.java
@@ -100,7 +100,7 @@ public class MonsterRoomFeature extends Feature<NoneFeatureConfiguration> {
                     if (worldGenLevel.isEmptyBlock(blockPos2)) {
                         int i14 = 0;
 
-                        for (Direction direction : Direction.Plane.HORIZONTAL) {
+                        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                             if (worldGenLevel.getBlockState(blockPos2.relative(direction)).isSolid()) {
                                 i14++;
                             }
diff --git a/net/minecraft/world/level/levelgen/feature/PointedDripstoneFeature.java b/net/minecraft/world/level/levelgen/feature/PointedDripstoneFeature.java
index 900de71..2d25091 100644
--- a/net/minecraft/world/level/levelgen/feature/PointedDripstoneFeature.java
+++ b/net/minecraft/world/level/levelgen/feature/PointedDripstoneFeature.java
@@ -49,7 +49,7 @@ public class PointedDripstoneFeature extends Feature<PointedDripstoneConfigurati
     private static void createPatchOfDripstoneBlocks(LevelAccessor level, RandomSource random, BlockPos pos, PointedDripstoneConfiguration config) {
         DripstoneUtils.placeDripstoneBlockIfPossible(level, pos);
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             if (!(random.nextFloat() > config.chanceOfDirectionalSpread)) {
                 BlockPos blockPos = pos.relative(direction);
                 DripstoneUtils.placeDripstoneBlockIfPossible(level, blockPos);
diff --git a/net/minecraft/world/level/levelgen/feature/UnderwaterMagmaFeature.java b/net/minecraft/world/level/levelgen/feature/UnderwaterMagmaFeature.java
index 5934fb6..de5beb0 100644
--- a/net/minecraft/world/level/levelgen/feature/UnderwaterMagmaFeature.java
+++ b/net/minecraft/world/level/levelgen/feature/UnderwaterMagmaFeature.java
@@ -59,7 +59,7 @@ public class UnderwaterMagmaFeature extends Feature<UnderwaterMagmaConfiguration
 
     private boolean isValidPlacement(WorldGenLevel level, BlockPos pos) {
         if (!this.isWaterOrAir(level, pos) && !this.isWaterOrAir(level, pos.below())) {
-            for (Direction direction : Direction.Plane.HORIZONTAL) {
+            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 if (this.isWaterOrAir(level, pos.relative(direction))) {
                     return false;
                 }
diff --git a/net/minecraft/world/level/levelgen/feature/configurations/MultifaceGrowthConfiguration.java b/net/minecraft/world/level/levelgen/feature/configurations/MultifaceGrowthConfiguration.java
index 10f0e59..538522c 100644
--- a/net/minecraft/world/level/levelgen/feature/configurations/MultifaceGrowthConfiguration.java
+++ b/net/minecraft/world/level/levelgen/feature/configurations/MultifaceGrowthConfiguration.java
@@ -75,7 +75,7 @@ public class MultifaceGrowthConfiguration implements FeatureConfiguration {
         }
 
         if (canPlaceOnWall) {
-            Direction.Plane.HORIZONTAL.forEach(this.validDirections::add);
+            this.validDirections.addElements(this.validDirections.size(), Direction.Plane.HORIZONTAL.faces); // Pluto - Expose Direction$Plane's faces
         }
     }
 
diff --git a/net/minecraft/world/level/levelgen/feature/foliageplacers/FoliagePlacer.java b/net/minecraft/world/level/levelgen/feature/foliageplacers/FoliagePlacer.java
index 8c67917..f74dffc 100644
--- a/net/minecraft/world/level/levelgen/feature/foliageplacers/FoliagePlacer.java
+++ b/net/minecraft/world/level/levelgen/feature/foliageplacers/FoliagePlacer.java
@@ -128,7 +128,7 @@ public abstract class FoliagePlacer {
         BlockPos blockPos = pos.below();
         BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             Direction clockWise = direction.getClockWise();
             int i1 = clockWise.getAxisDirection() == Direction.AxisDirection.POSITIVE ? range + i : range;
             mutableBlockPos.setWithOffset(pos, 0, localY - 1, 0).move(clockWise, i1).move(direction, -range);
diff --git a/net/minecraft/world/level/levelgen/feature/rootplacers/MangroveRootPlacer.java b/net/minecraft/world/level/levelgen/feature/rootplacers/MangroveRootPlacer.java
index 9917a13..14058c1 100644
--- a/net/minecraft/world/level/levelgen/feature/rootplacers/MangroveRootPlacer.java
+++ b/net/minecraft/world/level/levelgen/feature/rootplacers/MangroveRootPlacer.java
@@ -54,7 +54,7 @@ public class MangroveRootPlacer extends RootPlacer {
 
         list.add(trunkOrigin.below());
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             BlockPos blockPos = trunkOrigin.relative(direction);
             List<BlockPos> list1 = Lists.newArrayList();
             if (!this.simulateRoots(level, random, blockPos, direction, trunkOrigin, list1, 0)) {
diff --git a/net/minecraft/world/level/levelgen/feature/treedecorators/CocoaDecorator.java b/net/minecraft/world/level/levelgen/feature/treedecorators/CocoaDecorator.java
index 203e389..1033694 100644
--- a/net/minecraft/world/level/levelgen/feature/treedecorators/CocoaDecorator.java
+++ b/net/minecraft/world/level/levelgen/feature/treedecorators/CocoaDecorator.java
@@ -36,7 +36,7 @@ public class CocoaDecorator extends TreeDecorator {
                     .filter(pos -> pos.getY() - y <= 2)
                     .forEach(
                         blockPos -> {
-                            for (Direction direction : Direction.Plane.HORIZONTAL) {
+                            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                                 if (randomSource.nextFloat() <= 0.25F) {
                                     Direction opposite = direction.getOpposite();
                                     BlockPos blockPos1 = blockPos.offset(opposite.getStepX(), 0, opposite.getStepZ());
diff --git a/net/minecraft/world/level/levelgen/structure/StructurePiece.java b/net/minecraft/world/level/levelgen/structure/StructurePiece.java
index a41b156..58e1623 100644
--- a/net/minecraft/world/level/levelgen/structure/StructurePiece.java
+++ b/net/minecraft/world/level/levelgen/structure/StructurePiece.java
@@ -419,7 +419,7 @@ public abstract class StructurePiece {
     public static BlockState reorient(BlockGetter level, BlockPos pos, BlockState state) {
         Direction direction = null;
 
-        for (Direction direction1 : Direction.Plane.HORIZONTAL) {
+        for (Direction direction1 : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             BlockPos blockPos = pos.relative(direction1);
             BlockState blockState = level.getBlockState(blockPos);
             if (blockState.is(Blocks.CHEST)) {
diff --git a/net/minecraft/world/level/levelgen/structure/structures/DesertPyramidPiece.java b/net/minecraft/world/level/levelgen/structure/structures/DesertPyramidPiece.java
index 0d2451a..25884ac 100644
--- a/net/minecraft/world/level/levelgen/structure/structures/DesertPyramidPiece.java
+++ b/net/minecraft/world/level/levelgen/structure/structures/DesertPyramidPiece.java
@@ -286,7 +286,7 @@ public class DesertPyramidPiece extends ScatteredFeaturePiece {
             this.placeBlock(level, Blocks.CHISELED_SANDSTONE.defaultBlockState(), 10, -10, 13, box);
             this.placeBlock(level, Blocks.CUT_SANDSTONE.defaultBlockState(), 10, -11, 13, box);
 
-            for (Direction direction : Direction.Plane.HORIZONTAL) {
+            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 if (!this.hasPlacedChest[direction.get2DDataValue()]) {
                     int i4 = direction.getStepX() * 2;
                     int i5 = direction.getStepZ() * 2;
diff --git a/net/minecraft/world/level/levelgen/structure/structures/WoodlandMansionPieces.java b/net/minecraft/world/level/levelgen/structure/structures/WoodlandMansionPieces.java
index 7501625..b7b21fa 100644
--- a/net/minecraft/world/level/levelgen/structure/structures/WoodlandMansionPieces.java
+++ b/net/minecraft/world/level/levelgen/structure/structures/WoodlandMansionPieces.java
@@ -168,7 +168,7 @@ public class WoodlandMansionPieces {
 
         @Nullable
         public Direction get1x2RoomDirection(WoodlandMansionPieces.SimpleGrid layout, int x, int y, int floor, int roomId) {
-            for (Direction direction : Direction.Plane.HORIZONTAL) {
+            for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 if (this.isRoomId(layout, x + direction.getStepX(), y + direction.getStepZ(), floor, roomId)) {
                     return direction;
                 }
@@ -284,7 +284,7 @@ public class WoodlandMansionPieces {
 
                 List<Direction> list1 = Lists.newArrayList();
 
-                for (Direction direction1 : Direction.Plane.HORIZONTAL) {
+                for (Direction direction1 : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                     if (this.thirdFloorGrid.get(i3 + direction1.getStepX(), i4 + direction1.getStepZ()) == 0) {
                         list1.add(direction1);
                     }
@@ -537,7 +537,7 @@ public class WoodlandMansionPieces {
                             flag1 = flag1 && (i8 & 8388608) == 8388608;
                             list.clear();
                             if ((i8 & 2097152) == 2097152) {
-                                for (Direction direction : Direction.Plane.HORIZONTAL) {
+                                for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                                     if (simpleGrid3.get(i7 + direction.getStepX(), i6 + direction.getStepZ()) == 1) {
                                         list.add(direction);
                                     }
diff --git a/net/minecraft/world/level/material/FlowingFluid.java b/net/minecraft/world/level/material/FlowingFluid.java
index a9c7966..ca6df49 100644
--- a/net/minecraft/world/level/material/FlowingFluid.java
+++ b/net/minecraft/world/level/material/FlowingFluid.java
@@ -98,7 +98,7 @@ public abstract class FlowingFluid extends Fluid {
         double d1 = 0.0;
         BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             mutableBlockPos.setWithOffset(pos, direction);
             FluidState fluidState1 = blockReader.getFluidState(mutableBlockPos);
             if (this.affectsFlow(fluidState1)) {
@@ -128,7 +128,7 @@ public abstract class FlowingFluid extends Fluid {
 
         Vec3 vec3 = new Vec3(d, 0.0, d1);
         if (fluidState.getValue(FALLING)) {
-            for (Direction direction1 : Direction.Plane.HORIZONTAL) {
+            for (Direction direction1 : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 mutableBlockPos.setWithOffset(pos, direction1);
                 if (this.isSolidFace(blockReader, mutableBlockPos, direction1) || this.isSolidFace(blockReader, mutableBlockPos.above(), direction1)) {
                     vec3 = vec3.normalize().add(0.0, -6.0, 0.0);
@@ -218,7 +218,7 @@ public abstract class FlowingFluid extends Fluid {
         int i1 = 0;
         BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             BlockPos blockPos = mutableBlockPos.setWithOffset(pos, direction);
             BlockState blockState = level.getBlockStateIfLoaded(blockPos); // Paper - Prevent chunk loading from fluid flowing
             if (blockState == null) continue; // Paper - Prevent chunk loading from fluid flowing
@@ -349,7 +349,7 @@ public abstract class FlowingFluid extends Fluid {
         visited.clear();
         queue.clear();
 
-        for (Direction dir : Direction.Plane.HORIZONTAL) {
+        for (Direction dir : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             if (dir == excludedDirection) continue;
 
             BlockPos neighborPos = startPos.relative(dir); // immutable
@@ -379,7 +379,7 @@ public abstract class FlowingFluid extends Fluid {
 
             if (current.depth >= slopeFindDistance) continue;
 
-            for (Direction dir : Direction.Plane.HORIZONTAL) {
+            for (Direction dir : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
                 if (dir == current.excludedDir) continue;
 
                 BlockPos nextPos = current.pos.relative(dir); // immutable
@@ -490,7 +490,7 @@ public abstract class FlowingFluid extends Fluid {
     private int sourceNeighborCount(LevelReader level, BlockPos pos) {
         int i = 0;
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             BlockPos blockPos = pos.relative(direction);
             FluidState fluidState = level.getFluidState(blockPos);
             if (this.isSourceBlockOfThisType(fluidState)) {
@@ -506,7 +506,7 @@ public abstract class FlowingFluid extends Fluid {
         Map<Direction, FluidState> map = Maps.newEnumMap(Direction.class);
         FlowingFluid.SpreadContext spreadContext = null;
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             BlockPos blockPos = pos.relative(direction);
             BlockState blockState = level.getBlockStateIfLoaded(blockPos); // Paper - Prevent chunk loading from fluid flowing
             if (blockState == null) continue; // Paper - Prevent chunk loading from fluid flowing
diff --git a/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java b/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java
index c598d91..da19fcb 100644
--- a/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java
+++ b/net/minecraft/world/level/pathfinder/SwimNodeEvaluator.java
@@ -59,7 +59,7 @@ public class SwimNodeEvaluator extends NodeEvaluator {
             }
         }
 
-        for (Direction direction1 : Direction.Plane.HORIZONTAL) {
+        for (Direction direction1 : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             Direction clockWise = direction1.getClockWise();
             if (hasMalus(map.get(direction1)) && hasMalus(map.get(clockWise))) {
                 Node node2 = this.findAcceptedNode(
diff --git a/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java b/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
index 7eb7a8a..be0ed27 100644
--- a/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
+++ b/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
@@ -129,7 +129,7 @@ public class WalkNodeEvaluator extends NodeEvaluator {
 
         double floorLevel = this.getFloorLevel(new BlockPos(node.x, node.y, node.z));
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             Node node1 = this.findAcceptedNode(node.x + direction.getStepX(), node.y, node.z + direction.getStepZ(), i1, floorLevel, direction, cachedPathType1);
             this.reusableNeighbors[direction.get2DDataValue()] = node1;
             if (this.isNeighborValid(node1, node)) {
@@ -137,7 +137,7 @@ public class WalkNodeEvaluator extends NodeEvaluator {
             }
         }
 
-        for (Direction directionx : Direction.Plane.HORIZONTAL) {
+        for (Direction directionx : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             Direction clockWise = directionx.getClockWise();
             if (this.isDiagonalValid(node, this.reusableNeighbors[directionx.get2DDataValue()], this.reusableNeighbors[clockWise.get2DDataValue()])) {
                 Node node2 = this.findAcceptedNode(
diff --git a/net/minecraft/world/level/redstone/RedstoneWireEvaluator.java b/net/minecraft/world/level/redstone/RedstoneWireEvaluator.java
index 865da65..c5ed04d 100644
--- a/net/minecraft/world/level/redstone/RedstoneWireEvaluator.java
+++ b/net/minecraft/world/level/redstone/RedstoneWireEvaluator.java
@@ -27,7 +27,7 @@ public abstract class RedstoneWireEvaluator {
     protected int getIncomingWireSignal(Level level, BlockPos pos) {
         int i = 0;
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for (Direction direction : Direction.Plane.HORIZONTAL.faces) { // Pluto - Expose Direction$Plane's faces
             BlockPos blockPos = pos.relative(direction);
             BlockState blockState = level.getBlockState(blockPos);
             i = Math.max(i, this.getWireSignal(blockPos, blockState));
