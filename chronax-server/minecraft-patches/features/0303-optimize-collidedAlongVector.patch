From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: hayanesuru <hayanesuru@outlook.jp>
Date: Tue, 21 Oct 2025 10:45:21 +0900
Subject: [PATCH] optimize collidedAlongVector


diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index f6d6197..dea7ebe 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -1749,7 +1749,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                 }
                 VoxelShape entityInsideCollisionShape = blockState.getEntityInsideCollisionShape(level, pos, this);
                 boolean flag = entityInsideCollisionShape == Shapes.block()
-                    || this.collidedWithShapeMovingFrom(vec3, vec31, entityInsideCollisionShape.move(new Vec3(pos)).toAabbs());
+                    || this.collidedWithShapeMovingFrom(vec3, vec31, entityInsideCollisionShape.move(new Vec3(pos))); // Leaf - optimize collidedAlongVector
                 if (flag) {
                     try {
                         stepBasedCollector.advanceStep(index, pos); // Paper - track position inside effect was triggered on
@@ -1783,15 +1783,30 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
     public boolean collidedWithFluid(FluidState fluid, BlockPos pos, Vec3 from, Vec3 to) {
         AABB aabb = fluid.getAABB(this.level(), pos);
-        return aabb != null && this.collidedWithShapeMovingFrom(from, to, List.of(aabb));
+        return aabb != null && this.collidedWithShapeMovingFrom(from, to, aabb); // Leaf - optimize collidedAlongVector
     }
 
     public boolean collidedWithShapeMovingFrom(Vec3 from, Vec3 to, List<AABB> boxes) {
+        // Leaf - optimize collidedAlongVector - diff on change
         AABB aabb = this.makeBoundingBox(from);
         Vec3 vec3 = to.subtract(from);
         return aabb.collidedAlongVector(vec3, boxes);
     }
 
+    // Leaf start - optimize collidedAlongVector
+    public final boolean collidedWithShapeMovingFrom(Vec3 from, Vec3 to, AABB boxes) {
+        AABB aabb = this.makeBoundingBox(from);
+        Vec3 vec3 = to.subtract(from);
+        return aabb.collidedAlongVector(vec3, boxes);
+    }
+    public final boolean collidedWithShapeMovingFrom(Vec3 from, Vec3 to, VoxelShape boxes) {
+        AABB aabb = this.makeBoundingBox(from);
+        Vec3 vec3 = to.subtract(from);
+        AABB box = boxes.moonrise$getSingleAABBRepresentation();
+        return box != null ? aabb.collidedAlongVector(vec3, box) : aabb.collidedAlongVector(vec3, boxes.toAabbs());
+    }
+    // Leaf end - optimize collidedAlongVector
+
     protected void onInsideBlock(BlockState state) {
     }
 
diff --git a/net/minecraft/world/entity/monster/Ghast.java b/net/minecraft/world/entity/monster/Ghast.java
index c249946..671b687 100644
--- a/net/minecraft/world/entity/monster/Ghast.java
+++ b/net/minecraft/world/entity/monster/Ghast.java
@@ -357,7 +357,7 @@ public class Ghast extends Mob implements Enemy {
             } else {
                 boolean flag = from != null && to != null;
                 boolean flag1 = flag
-                    ? !this.ghast.collidedWithShapeMovingFrom(from, to, blockState.getCollisionShape(level, pos).move(new Vec3(pos)).toAabbs())
+                    ? !this.ghast.collidedWithShapeMovingFrom(from, to, blockState.getCollisionShape(level, pos).move(new Vec3(pos))) // Leaf - optimize collidedAlongVector
                     : blockState.getCollisionShape(level, pos).isEmpty();
                 if (!this.careful) {
                     return flag1;
diff --git a/net/minecraft/world/phys/AABB.java b/net/minecraft/world/phys/AABB.java
index 2010b30..67f1b17 100644
--- a/net/minecraft/world/phys/AABB.java
+++ b/net/minecraft/world/phys/AABB.java
@@ -418,21 +418,34 @@ public class AABB {
         }
     }
 
+    // Leaf start - optimize collidedAlongVector
+    public final boolean collidedAlongVector(Vec3 vector, AABB aabb) {
+        Vec3 center = this.getCenter();
+        Vec3 vec3 = center.add(vector);
+        AABB aabb1 = aabb.inflate(this.getXsize() * 0.5, this.getYsize() * 0.5, this.getZsize() * 0.5);
+        return aabb1.contains(vec3) || aabb1.contains(center) || aabb1.clip(center, vec3).isPresent();
+    }
+    // Leaf end - optimize collidedAlongVector
+
     public boolean collidedAlongVector(Vec3 vector, List<AABB> boxes) {
+        // Leaf - optimize collidedAlongVector - diff on change
         Vec3 center = this.getCenter();
         Vec3 vec3 = center.add(vector);
 
         for (AABB aabb : boxes) {
+            // Leaf - optimize collidedAlongVector - diff on change
             AABB aabb1 = aabb.inflate(this.getXsize() * 0.5, this.getYsize() * 0.5, this.getZsize() * 0.5);
             if (aabb1.contains(vec3) || aabb1.contains(center)) {
                 return true;
             }
 
+            // Leaf - optimize collidedAlongVector - diff on change
             if (aabb1.clip(center, vec3).isPresent()) {
                 return true;
             }
         }
 
+        // Leaf - optimize collidedAlongVector - diff on change
         return false;
     }
 
